// Generated by CoffeeScript 1.9.3
var Parser, base,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  slice = [].slice;

if ((base = Array.prototype).every == null) {
  base.every = function(f) {
    var j, len, x;
    for (j = 0, len = this.length; j < len; j++) {
      x = this[j];
      if (!f(x)) {
        return false;
      }
    }
    return true;
  };
}

Parser = (function() {
  var BLANK, MATCH_TOKENS, NEXT_CLASSES, NEXT_LENGTH, NEXT_TOKENS, PREV_CLASSES, PREV_LENGTH, PREV_TOKENS, PRODUCTION, RULE, TOKEN, TOKENS, TOKENS_LENGTH;

  BLANK = [' '];

  RULE = 'rule';

  TOKEN = 'token';

  PRODUCTION = 'production';

  TOKENS_LENGTH = 'tokens_length';

  PRODUCTION = 0;

  PREV_CLASSES = 1;

  PREV_TOKENS = 2;

  TOKENS = 3;

  NEXT_TOKENS = 4;

  NEXT_CLASSES = 5;

  PREV_LENGTH = 6;

  NEXT_LENGTH = 7;

  MATCH_TOKENS = 8;

  TOKENS_LENGTH = 9;

  function Parser(name, tokens, token_regex, graph, onmatch, compressed) {
    this.name = name;
    this.tokens = tokens;
    this.token_regex = token_regex;
    this.graph = graph;
    this.onmatch = onmatch;
    this.compressed = compressed;
    this.out_edges = this.get_edges_sorted_by_next_token();
    this.parse_tokens = [];
    this.token_i = 0;
    if (this.onmatch) {
      this.onmatch_rules_token_matrix = this.get_onmatch_rules_token_matrix();
      this.onmatch_rules_by_token = this.get_onmatch_rules_by_token();
    }
    if (this.graph.compressed) {
      RULE = 'r';
      TOKEN = 't';
      PREV_CLASSES = 'pc';
      NEXT_CLASSES = 'nc';
      PREV_LENGTH = 'pl';
      NEXT_LENGTH = 'nl';
      MATCH_TOKENS = 'mt';
      PRODUCTION = 'p';
      TOKENS_LENGTH = 'tl';
    }
  }

  Parser.prototype.arrayEqual = function(ar1, ar2) {
    return JSON.stringify(ar1) === JSON.stringify(ar2);
  };

  Parser.prototype.tokenize = function(string) {
    return string.match(this.token_regex);
  };

  Parser.prototype.get_edges_sorted_by_next_token = function() {
    var base1, edge, edge_data, edges, end_n, end_nid, j, len, output, ref, sorted_out_edges_by_next_tokens, sorted_out_edges_no_tokens, start_n, start_node, tkn;
    sorted_out_edges_by_next_tokens = [];
    sorted_out_edges_no_tokens = [];
    ref = this.graph.edge;
    for (start_node in ref) {
      edges = ref[start_node];
      for (j = 0, len = edges.length; j < len; j++) {
        edge = edges[j];
        start_n = edge[0];
        end_nid = edge[1];
        edge_data = edge[2];
        end_n = this.graph.node[end_nid];
        tkn = end_n[TOKEN];
        if (tkn) {
          if (sorted_out_edges_by_next_tokens[start_n] == null) {
            sorted_out_edges_by_next_tokens[start_n] = [];
          }
          ((base1 = sorted_out_edges_by_next_tokens[start_n])[tkn] != null ? base1[tkn] : base1[tkn] = []).push(edge);
        } else {
          (sorted_out_edges_no_tokens[start_n] != null ? sorted_out_edges_no_tokens[start_n] : sorted_out_edges_no_tokens[start_n] = []).push(edge);
        }
      }
    }
    return output = {
      'no_tokens': sorted_out_edges_no_tokens,
      'by_tokens': sorted_out_edges_by_next_tokens
    };
  };

  Parser.prototype.get_onmatch_rules_by_token = function() {
    var curr_class, j, len, match_rules, o, prod, ref, ref1, ref2, t, t_classes, t_om;
    t_om = [];
    ref = this.tokens;
    for (t in ref) {
      t_classes = ref[t];
      t_om[t] = [];
      ref1 = this.onmatch;
      for (j = 0, len = ref1.length; j < len; j++) {
        o = ref1[j];
        match_rules = o[0];
        prod = o[1];
        curr_class = match_rules[1];
        if (ref2 = curr_class[0], indexOf.call(t_classes, ref2) >= 0) {
          t_om[t].push(o);
        }
      }
    }
    return t_om;
  };

  Parser.prototype.get_onmatch_rules_token_matrix = function() {
    var curr_class, j, len, match_rules, o, prev_class, prod, ref, ref1, ref2, ref3, t, t2, t2_class, t2_classes, t_classes, ttm;
    ttm = [];
    ref = this.tokens;
    for (t in ref) {
      t_classes = ref[t];
      ttm[t] = [];
      ref1 = this.tokens;
      for (t2 in ref1) {
        t2_classes = ref1[t2];
        ttm[t][t2] = [];
      }
      ref2 = this.onmatch;
      for (j = 0, len = ref2.length; j < len; j++) {
        o = ref2[j];
        match_rules = o[0];
        prod = o[1];
        curr_class = match_rules[1];
        if (t_classes.indexOf(curr_class[0]) > 0) {
          ref3 = this.tokens;
          for (t2 in ref3) {
            t2_class = ref3[t2];
            prev_class = match_rules[0];
            if (t2_class.indexOf(prev_class[0]) > 0) {
              ttm[t][t2].push(o);
            }
          }
        }
      }
    }
    return ttm;
  };

  Parser.prototype.match_rule = function(rule, level) {
    var i, i_start, j, k, match_tokens, next_classes, prev_classes, ref, ref1, ref2, ref3, ref4, to_match, x;
    match_tokens = rule[MATCH_TOKENS];
    i_start = this.token_i - rule[PREV_LENGTH];
    if (i_start < 0 || i_start + match_tokens.length > this.parse_tokens.length) {
      return false;
    }
    if (!this.arrayEqual(match_tokens, this.parse_tokens.slice(i_start, i_start + match_tokens.length))) {
      return false;
    }
    if (rule[PREV_CLASSES]) {
      prev_classes = rule[PREV_CLASSES].reverse();
      x = i_start - prev_classes.length;
      if (x < -1) {
        return false;
      } else if (x === -1) {
        to_match = BLANK.concat(this.parse_tokens.slice(i_start - prev_classes.length + 1, i_start));
      } else {
        to_match = this.parse_tokens.slice(i_start - prev_classes.length, i_start);
      }
      to_match = to_match.reverse();
      for (i = j = 0, ref = prev_classes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        if (ref1 = !to_match[i], indexOf.call(this.tokens, ref1) >= 0) {
          console.log('bad prev token:' + i);
          return false;
        }
        if (!prev_classes[i] || !(ref2 = prev_classes[i], indexOf.call(this.tokens[to_match[i]], ref2) >= 0)) {
          return false;
        }
      }
    }
    if (rule[NEXT_CLASSES]) {
      next_classes = rule[NEXT_CLASSES];
      if (i_start + match_tokens.length + next_classes.length > 1 + this.parse_tokens.length) {
        return false;
      }
      to_match = slice.call(this.parse_tokens.slice(i_start + match_tokens.length, i_start + match_tokens.length + next_classes.length)).concat(slice.call(BLANK));
      if (!(to_match != null)) {
        console.log('bad to_match for token ' + i);
        return false;
      }
      for (i = k = 0, ref3 = next_classes.length - 1; 0 <= ref3 ? k <= ref3 : k >= ref3; i = 0 <= ref3 ? ++k : --k) {
        if (!(this.tokens[to_match[i]] != null)) {
          console.log('bad next token:' + i);
          return false;
        }
        if (!next_classes[i] || !(ref4 = next_classes[i], indexOf.call(this.tokens[to_match[i]], ref4) >= 0)) {
          return false;
        }
      }
    }
    return true;
  };

  Parser.prototype.descend_node = function(curr_node, level) {
    var curr_token, d, edge, edge_properties, j, len, new_edges, next_node, next_node_id;
    new_edges = [];
    if (this.token_i + level < this.parse_tokens.length) {
      curr_token = this.parse_tokens[this.token_i + level];
      if (this.out_edges.by_tokens[curr_node]) {
        if (this.out_edges.by_tokens[curr_node][curr_token]) {
          new_edges = this.out_edges.by_tokens[curr_node][curr_token];
        }
      }
    }
    if (this.out_edges.no_tokens[curr_node] != null) {
      new_edges = new_edges.concat(this.out_edges.no_tokens[curr_node]);
    }
    for (j = 0, len = new_edges.length; j < len; j++) {
      edge = new_edges[j];
      next_node_id = edge[1];
      edge_properties = edge[2];
      if (edge_properties[RULE]) {
        if (this.match_rule(edge_properties[RULE], level) === false) {
          continue;
        }
      }
      next_node = this.graph.node[next_node_id];
      if (next_node[RULE]) {
        return next_node[RULE];
      }
      if (this.token_i + level < this.parse_tokens.length) {
        d = this.descend_node(next_node_id, level + 1);
      }
      if (d) {
        return d;
      }
    }
  };

  Parser.prototype.match_first_at = function() {
    return this.descend_node(0, 0);
  };

  Parser.prototype.test_omr_classes = function(omr_classes, classes_to_test) {
    var found, i, j, ref, ref1;
    for (i = j = 0, ref = omr_classes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (classes_to_test[i] != null) {
        found = (ref1 = omr_classes[i], indexOf.call(classes_to_test[i], ref1) >= 0);
      } else {
        console.log('could not find class ' + i + ' in omr_classes');
      }
      if (!found) {
        return false;
      }
    }
    return true;
  };

  Parser.prototype.parse = function(string, debug) {
    var c, classes, classes_to_test_l, classes_to_test_r, j, k, l, l_c, len, len1, len2, m, matches, mr, mt_i, mtkns, omr, output, p, r_c, ref, ref1, t_i;
    if (debug) {
      console.log('parsing ' + string);
      debugger;
    }
    string = string.toLowerCase();
    this.token_i = 0;
    this.parse_tokens = this.tokenize(string);
    if (this.onmatch) {
      mtkns = slice.call(BLANK).concat(slice.call(this.parse_tokens), slice.call(BLANK));
    }
    output = '';
    matches = [];
    while (this.token_i < this.parse_tokens.length) {
      m = this.match_first_at(this.token_i);
      if (!m) {
        console.log('bad character ' + this.parse_tokens[this.token_i] + ' at pos ' + this.token_i + ' in ' + string);
        this.token_i += 1;
        continue;
      }
      matches.push(m);
      if (this.onmatch) {
        t_i = this.token_i;
        mt_i = t_i + 1;
        omr = this.onmatch_rules_by_token[this.parse_tokens[t_i]];
        if (omr) {
          for (j = 0, len = omr.length; j < len; j++) {
            mr = omr[j];
            classes = mr[0];
            p = mr[1];
            l_c = classes[0];
            r_c = classes[1];
            if (mt_i < l_c.length || mt_i + r_c.length > mtkns.length) {
              continue;
            }
            classes_to_test_l = [];
            classes_to_test_r = [];
            ref = mtkns.slice(mt_i - l_c.length, mt_i);
            for (k = 0, len1 = ref.length; k < len1; k++) {
              c = ref[k];
              classes_to_test_l.push(this.tokens[c]);
            }
            ref1 = mtkns.slice(mt_i, mt_i + r_c.length);
            for (l = 0, len2 = ref1.length; l < len2; l++) {
              c = ref1[l];
              classes_to_test_r.push(this.tokens[c]);
            }
            if (this.test_omr_classes(l_c, classes_to_test_l) && this.test_omr_classes(r_c, classes_to_test_r)) {
              output = output + p;
              break;
            }
          }
        }
      }
      output += m[PRODUCTION];
      this.token_i += m[TOKENS_LENGTH];
    }
    return output;
  };

  return Parser;

})();

window.p_hi = new Parser('devanagari', devanagari_tokens, devanagari_token_regex, devanagari_graph, devanagari_onmatch);

window.p_ur = new Parser('urdu', urdu_tokens, urdu_token_regex, urdu_graph, urdu_onmatch);
